{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Project Setup with NextJS, TailwindCSS, and ShadUI",
        "description": "Initialize the project with NextJS App Directory structure, configure TailwindCSS for styling, and integrate ShadUI for reusable components.",
        "details": "1. Create a new NextJS project using the App Directory structure:\n```bash\nnpx create-next-app@latest chatbot-app --typescript --eslint --app --tailwind\ncd chatbot-app\n```\n2. Install ShadUI and its dependencies:\n```bash\nnpm install @shadcn/ui\nnpx shadcn-ui init\n```\n3. Configure the project structure:\n   - Create `/app` directory with layout.tsx and page.tsx\n   - Set up `/components` directory for UI components\n   - Configure `/lib` directory for utility functions\n4. Set up environment variables in .env.local for API keys\n5. Initialize Git repository and create initial commit",
        "testStrategy": "Verify project setup by running the development server and confirming that the application loads without errors. Check that TailwindCSS styles are applied correctly and ShadUI components can be imported and rendered.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Supabase Local Setup and Database Schema",
        "description": "Set up a local Supabase instance and create the database schema for storing chat sessions and messages.",
        "details": "1. Install Supabase CLI:\n```bash\nnpm install -g supabase\n```\n2. Initialize local Supabase instance:\n```bash\nsupabase init\nsupabase start\n```\n3. Create database migrations for the required tables:\n```sql\n-- Create chat_sessions table\nCREATE TABLE chat_sessions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  title TEXT NOT NULL\n);\n\n-- Create chat_messages table\nCREATE TABLE chat_messages (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  chat_id UUID REFERENCES chat_sessions(id) ON DELETE CASCADE,\n  role TEXT CHECK (role IN ('user', 'assistant')),\n  content TEXT NOT NULL,\n  type TEXT CHECK (type IN ('text', 'image')),\n  image_url TEXT\n);\n```\n4. Apply migrations to local database:\n```bash\nsupabase db push\n```\n5. Generate TypeScript types for the database schema:\n```bash\nsupabase gen types typescript --local > lib/database.types.ts\n```",
        "testStrategy": "Verify the database setup by connecting to the local Supabase instance and confirming that the tables have been created with the correct schema. Test CRUD operations on both tables to ensure they function as expected.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Document Chat and Message Models",
            "description": "Create detailed documentation of the Chat and Message models, including their relationships, constraints, and indexes.",
            "dependencies": [],
            "details": "1. Define the Chat Session model with fields:\n   - id (UUID, primary key)\n   - created_at (timestamp)\n   - updated_at (timestamp)\n   - title (text)\n\n2. Define the Chat Message model with fields:\n   - id (UUID, primary key)\n   - created_at (timestamp)\n   - chat_id (UUID, foreign key)\n   - role (text, enum: 'user', 'assistant')\n   - content (text)\n   - type (text, enum: 'text', 'image')\n   - image_url (text, nullable)\n\n3. Document the relationships between models:\n   - One-to-many relationship between Chat Session and Chat Messages\n   - Cascade deletion from Chat Session to Chat Messages\n\n4. Create an entity relationship diagram (ERD) showing the models and their relationships.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Supabase Migrations for Database Schema",
            "description": "Create and apply Supabase migrations to set up the database schema with proper constraints, indexes, and foreign keys.",
            "dependencies": [
              "2.1"
            ],
            "details": "1. Install Supabase CLI and initialize local instance:\n```bash\nnpm install -g supabase\nsupabase init\nsupabase start\n```\n\n2. Create migration file for chat_sessions table:\n```sql\nCREATE TABLE chat_sessions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  title TEXT NOT NULL\n);\n\n-- Add index for faster querying by creation date\nCREATE INDEX idx_chat_sessions_created_at ON chat_sessions(created_at);\n```\n\n3. Create migration file for chat_messages table:\n```sql\nCREATE TABLE chat_messages (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  chat_id UUID REFERENCES chat_sessions(id) ON DELETE CASCADE,\n  role TEXT CHECK (role IN ('user', 'assistant')),\n  content TEXT NOT NULL,\n  type TEXT CHECK (type IN ('text', 'image')),\n  image_url TEXT\n);\n\n-- Add indexes for faster querying\nCREATE INDEX idx_chat_messages_chat_id ON chat_messages(chat_id);\nCREATE INDEX idx_chat_messages_created_at ON chat_messages(created_at);\n```\n\n4. Apply migrations and generate TypeScript types:\n```bash\nsupabase db push\nsupabase gen types typescript --local > lib/database.types.ts\n```",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Test and Validate Database Schema",
            "description": "Test the database schema by performing CRUD operations and validating constraints and relationships.",
            "dependencies": [
              "2.2"
            ],
            "details": "1. Create test script to verify database schema:\n```typescript\n// tests/database-schema.test.ts\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabase = createClient('http://localhost:54321', 'your-local-anon-key');\n\nasync function testDatabaseSchema() {\n  // Test creating a chat session\n  const { data: chatSession, error: chatError } = await supabase\n    .from('chat_sessions')\n    .insert({ title: 'Test Chat' })\n    .select()\n    .single();\n  \n  console.log('Created chat session:', chatSession, chatError);\n  \n  // Test creating messages\n  const { data: message1, error: msgError1 } = await supabase\n    .from('chat_messages')\n    .insert({\n      chat_id: chatSession.id,\n      role: 'user',\n      content: 'Hello AI',\n      type: 'text'\n    })\n    .select()\n    .single();\n  \n  console.log('Created user message:', message1, msgError1);\n  \n  // Test constraints (should fail)\n  const { data: invalidMsg, error: invalidError } = await supabase\n    .from('chat_messages')\n    .insert({\n      chat_id: chatSession.id,\n      role: 'invalid_role', // Should fail CHECK constraint\n      content: 'Test',\n      type: 'text'\n    });\n  \n  console.log('Invalid role test (should fail):', invalidError);\n  \n  // Test cascade delete\n  const { error: deleteError } = await supabase\n    .from('chat_sessions')\n    .delete()\n    .eq('id', chatSession.id);\n  \n  console.log('Deleted chat session:', deleteError);\n  \n  // Verify messages were also deleted\n  const { data: remainingMsgs, error: queryError } = await supabase\n    .from('chat_messages')\n    .select()\n    .eq('chat_id', chatSession.id);\n  \n  console.log('Remaining messages (should be empty):', remainingMsgs, queryError);\n}\n\ntestDatabaseSchema();\n```\n\n2. Run the test script and verify:\n   - Chat sessions can be created with required fields\n   - Messages can be created with proper foreign key references\n   - Constraints prevent invalid data (role, type)\n   - Cascade deletion works correctly\n   - Indexes are properly created\n\n3. Document any issues found and make necessary adjustments to the schema.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Chat Interface UI Components",
        "description": "Create the UI components for the chat interface, including message display, input area, and basic layout.",
        "details": "1. Create the following components:\n   - ChatContainer: Main container for the chat interface\n   - MessageList: Component to display chat messages\n   - MessageItem: Individual message component with user/AI styling\n   - ChatInput: Text input component with send button\n   - ToggleButton: Switch between text and image modes\n   - NewChatButton: Button to start a new chat\n\n2. Implement responsive layout using TailwindCSS:\n```tsx\n// components/ChatContainer.tsx\nexport function ChatContainer({ children }: { children: React.ReactNode }) {\n  return (\n    <div className=\"flex flex-col h-screen max-w-3xl mx-auto p-4\">\n      <header className=\"py-4 border-b\">\n        <h1 className=\"text-2xl font-bold\">AI Chat Assistant</h1>\n      </header>\n      <main className=\"flex-1 overflow-hidden flex flex-col\">\n        {children}\n      </main>\n    </div>\n  );\n}\n```\n\n3. Style message items to distinguish between user and AI:\n```tsx\n// components/MessageItem.tsx\nexport function MessageItem({ message }: { message: ChatMessage }) {\n  const isUser = message.role === 'user';\n  return (\n    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>\n      <div className={`max-w-[80%] p-3 rounded-lg ${isUser ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}>\n        {message.type === 'text' ? (\n          <p>{message.content}</p>\n        ) : (\n          <img src={message.image_url} alt=\"Generated image\" className=\"rounded\" />\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n4. Create the chat input component with mode toggle:\n```tsx\n// components/ChatInput.tsx\nexport function ChatInput({ onSend, mode, onToggleMode }: ChatInputProps) {\n  const [input, setInput] = useState('');\n  \n  return (\n    <div className=\"border-t p-4\">\n      <div className=\"flex items-center mb-2\">\n        <button\n          onClick={onToggleMode}\n          className={`px-3 py-1 rounded-md ${mode === 'text' ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}\n        >\n          {mode === 'text' ? 'Text Mode' : 'Image Mode'}\n        </button>\n      </div>\n      <div className=\"flex\">\n        <input\n          type=\"text\"\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          placeholder={mode === 'text' ? 'Type a message...' : 'Describe the image you want...'}\n          className=\"flex-1 p-2 border rounded-l-md\"\n        />\n        <button\n          onClick={() => {\n            if (input.trim()) {\n              onSend(input);\n              setInput('');\n            }\n          }}\n          className=\"bg-blue-500 text-white p-2 rounded-r-md\"\n        >\n          Send\n        </button>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "Render each component in isolation using a component testing library to verify appearance and behavior. Test responsive design by viewing components at different screen sizes. Verify that user and AI messages are visually distinct and that the input component correctly handles text entry and submission.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "OpenAI API Integration for Text Chat",
        "description": "Implement the integration with OpenAI's GPT-4.1-nano model for text-based chat functionality.",
        "details": "1. Install OpenAI SDK:\n```bash\nnpm install openai\n```\n\n2. Create an API utility for OpenAI interactions:\n```typescript\n// lib/openai.ts\nimport OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport async function generateChatCompletion(messages: any[]) {\n  return openai.chat.completions.create({\n    model: 'gpt-4.1-nano-2025-04-14',\n    messages,\n    stream: true,\n  });\n}\n```\n\n3. Create a Supabase Edge Function to handle chat requests:\n```typescript\n// supabase/functions/chat/index.ts\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\nimport { OpenAI } from 'https://esm.sh/openai@4';\n\nserve(async (req) => {\n  const { messages, chatId } = await req.json();\n  \n  const openai = new OpenAI({\n    apiKey: Deno.env.get('OPENAI_API_KEY'),\n  });\n  \n  const supabase = createClient(\n    Deno.env.get('SUPABASE_URL') ?? '',\n    Deno.env.get('SUPABASE_ANON_KEY') ?? ''\n  );\n  \n  // Store user message\n  const userMessage = messages[messages.length - 1];\n  await supabase.from('chat_messages').insert({\n    chat_id: chatId,\n    role: userMessage.role,\n    content: userMessage.content,\n    type: 'text'\n  });\n  \n  // Get streaming response from OpenAI\n  const stream = await openai.chat.completions.create({\n    model: 'gpt-4.1-nano-2025-04-14',\n    messages,\n    stream: true,\n  });\n  \n  // Return stream to client\n  return new Response(stream, {\n    headers: {\n      'Content-Type': 'text/event-stream',\n    },\n  });\n});\n```\n\n4. Create a client-side hook to handle chat interactions:\n```typescript\n// hooks/useChat.ts\nimport { useState, useCallback } from 'react';\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n\nexport function useChat() {\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [chatId, setChatId] = useState<string | null>(null);\n  \n  const sendMessage = useCallback(async (content: string) => {\n    setIsLoading(true);\n    \n    // Create chat session if none exists\n    if (!chatId) {\n      const { data } = await supabase\n        .from('chat_sessions')\n        .insert({ title: content.substring(0, 50) })\n        .select()\n        .single();\n      \n      setChatId(data.id);\n    }\n    \n    // Add user message to UI\n    const userMessage = {\n      role: 'user',\n      content,\n      type: 'text',\n    };\n    \n    setMessages(prev => [...prev, userMessage]);\n    \n    // Format messages for API\n    const apiMessages = messages.map(m => ({\n      role: m.role,\n      content: m.content,\n    }));\n    apiMessages.push({ role: 'user', content });\n    \n    try {\n      const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ messages: apiMessages, chatId }),\n      });\n      \n      // Handle streaming response\n      // Implementation details for streaming would go here\n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [messages, chatId]);\n  \n  return { messages, sendMessage, isLoading };\n}\n```",
        "testStrategy": "Test the OpenAI integration by sending test messages and verifying responses. Mock the OpenAI API for unit tests to avoid API costs during testing. Verify that messages are correctly stored in the Supabase database and that the chat session is created properly. Test error handling by simulating API failures.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Text Response Streaming",
        "description": "Implement real-time streaming of AI responses as they're generated to provide immediate feedback to users.",
        "details": "1. Create a streaming utility function:\n```typescript\n// lib/streamUtils.ts\nexport async function streamReader(response: Response, onChunk: (chunk: string) => void) {\n  const reader = response.body?.getReader();\n  if (!reader) return;\n\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      \n      buffer += decoder.decode(value, { stream: true });\n      \n      // Process buffer for SSE format\n      const lines = buffer.split('\\n\\n');\n      buffer = lines.pop() || '';\n      \n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6);\n          if (data === '[DONE]') continue;\n          \n          try {\n            const json = JSON.parse(data);\n            const content = json.choices[0]?.delta?.content || '';\n            if (content) onChunk(content);\n          } catch (e) {\n            console.error('Error parsing JSON:', e);\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n```\n\n2. Update the chat hook to handle streaming:\n```typescript\n// hooks/useChat.ts (updated sendMessage function)\nconst sendMessage = useCallback(async (content: string) => {\n  setIsLoading(true);\n  \n  // Create chat session if none exists\n  if (!chatId) {\n    const { data } = await supabase\n      .from('chat_sessions')\n      .insert({ title: content.substring(0, 50) })\n      .select()\n      .single();\n    \n    setChatId(data.id);\n  }\n  \n  // Add user message to UI\n  const userMessage = {\n    role: 'user',\n    content,\n    type: 'text',\n  };\n  \n  setMessages(prev => [...prev, userMessage]);\n  \n  // Create placeholder for assistant response\n  const assistantMessage = {\n    role: 'assistant',\n    content: '',\n    type: 'text',\n  };\n  \n  setMessages(prev => [...prev, assistantMessage]);\n  \n  // Format messages for API\n  const apiMessages = messages.map(m => ({\n    role: m.role,\n    content: m.content,\n  }));\n  apiMessages.push({ role: 'user', content });\n  \n  try {\n    const response = await fetch('/api/chat', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ messages: apiMessages, chatId }),\n    });\n    \n    // Handle streaming response\n    let fullResponse = '';\n    \n    await streamReader(response, (chunk) => {\n      fullResponse += chunk;\n      \n      // Update the assistant message with accumulated response\n      setMessages(prev => {\n        const newMessages = [...prev];\n        const lastMessage = newMessages[newMessages.length - 1];\n        if (lastMessage.role === 'assistant') {\n          lastMessage.content = fullResponse;\n        }\n        return newMessages;\n      });\n    });\n    \n    // Store the complete assistant response in Supabase\n    await supabase.from('chat_messages').insert({\n      chat_id: chatId,\n      role: 'assistant',\n      content: fullResponse,\n      type: 'text'\n    });\n    \n  } catch (error) {\n    console.error('Error sending message:', error);\n  } finally {\n    setIsLoading(false);\n  }\n}, [messages, chatId]);\n```\n\n3. Create a component to display streaming text:\n```tsx\n// components/StreamingText.tsx\nimport { useEffect, useRef } from 'react';\n\nexport function StreamingText({ text }: { text: string }) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  useEffect(() => {\n    if (containerRef.current) {\n      containerRef.current.scrollIntoView({ behavior: 'smooth' });\n    }\n  }, [text]);\n  \n  return (\n    <div ref={containerRef} className=\"whitespace-pre-wrap\">\n      {text || <span className=\"animate-pulse\">▋</span>}\n    </div>\n  );\n}\n```\n\n4. Update the MessageItem component to use StreamingText:\n```tsx\n// components/MessageItem.tsx (updated)\nexport function MessageItem({ message, isStreaming }: { message: ChatMessage, isStreaming?: boolean }) {\n  const isUser = message.role === 'user';\n  return (\n    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>\n      <div className={`max-w-[80%] p-3 rounded-lg ${isUser ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}>\n        {message.type === 'text' ? (\n          isStreaming ? (\n            <StreamingText text={message.content} />\n          ) : (\n            <p>{message.content}</p>\n          )\n        ) : (\n          <img src={message.image_url} alt=\"Generated image\" className=\"rounded\" />\n        )}\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "Test streaming functionality by sending messages and verifying that responses appear incrementally. Measure response time and rendering performance. Test with various response lengths to ensure the UI remains responsive. Verify that the complete response is correctly stored in the database after streaming completes.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Image Generation Mode",
        "description": "Add the ability to generate images using OpenAI's gpt-image-1 model and implement the toggle between text and image generation modes.",
        "details": "1. Extend the OpenAI utility to support image generation:\n```typescript\n// lib/openai.ts (extended)\nexport async function generateImage(prompt: string) {\n  return openai.images.generate({\n    model: 'gpt-image-1',\n    prompt,\n    n: 1,\n    size: '1024x1024',\n  });\n}\n```\n\n2. Create a Supabase Edge Function for image generation:\n```typescript\n// supabase/functions/generate-image/index.ts\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2';\nimport { OpenAI } from 'https://esm.sh/openai@4';\n\nserve(async (req) => {\n  const { prompt, chatId } = await req.json();\n  \n  const openai = new OpenAI({\n    apiKey: Deno.env.get('OPENAI_API_KEY'),\n  });\n  \n  const supabase = createClient(\n    Deno.env.get('SUPABASE_URL') ?? '',\n    Deno.env.get('SUPABASE_ANON_KEY') ?? ''\n  );\n  \n  // Store user prompt\n  await supabase.from('chat_messages').insert({\n    chat_id: chatId,\n    role: 'user',\n    content: prompt,\n    type: 'text'\n  });\n  \n  try {\n    // Generate image\n    const response = await openai.images.generate({\n      model: 'gpt-image-1',\n      prompt,\n      n: 1,\n      size: '1024x1024',\n    });\n    \n    const imageUrl = response.data[0].url;\n    \n    // Store assistant response with image\n    await supabase.from('chat_messages').insert({\n      chat_id: chatId,\n      role: 'assistant',\n      content: 'Image generated based on your prompt',\n      type: 'image',\n      image_url: imageUrl\n    });\n    \n    return new Response(JSON.stringify({ imageUrl }), {\n      headers: { 'Content-Type': 'application/json' },\n    });\n  } catch (error) {\n    return new Response(JSON.stringify({ error: error.message }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n});\n```\n\n3. Update the chat hook to support image generation mode:\n```typescript\n// hooks/useChat.ts (extended)\nexport function useChat() {\n  const [messages, setMessages] = useState<ChatMessage[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [chatId, setChatId] = useState<string | null>(null);\n  const [mode, setMode] = useState<'text' | 'image'>('text');\n  \n  const toggleMode = useCallback(() => {\n    setMode(prev => prev === 'text' ? 'image' : 'text');\n  }, []);\n  \n  const sendMessage = useCallback(async (content: string) => {\n    setIsLoading(true);\n    \n    // Create chat session if none exists\n    if (!chatId) {\n      const { data } = await supabase\n        .from('chat_sessions')\n        .insert({ title: content.substring(0, 50) })\n        .select()\n        .single();\n      \n      setChatId(data.id);\n    }\n    \n    // Add user message to UI\n    const userMessage = {\n      role: 'user',\n      content,\n      type: 'text',\n    };\n    \n    setMessages(prev => [...prev, userMessage]);\n    \n    try {\n      if (mode === 'text') {\n        // Text chat logic (as implemented before)\n        // ...\n      } else {\n        // Image generation logic\n        const response = await fetch('/api/generate-image', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ prompt: content, chatId }),\n        });\n        \n        const { imageUrl, error } = await response.json();\n        \n        if (error) throw new Error(error);\n        \n        // Add assistant message with image\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: 'Image generated based on your prompt',\n          type: 'image',\n          image_url: imageUrl\n        }]);\n      }\n    } catch (error) {\n      console.error('Error:', error);\n      // Show error message\n      setMessages(prev => [...prev, {\n        role: 'assistant',\n        content: `Error: ${error.message}`,\n        type: 'text'\n      }]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [messages, chatId, mode]);\n  \n  return { messages, sendMessage, isLoading, mode, toggleMode };\n}\n```\n\n4. Update the UI to indicate the current mode:\n```tsx\n// components/ModeToggle.tsx\nexport function ModeToggle({ mode, onToggle }: { mode: 'text' | 'image', onToggle: () => void }) {\n  return (\n    <div className=\"flex items-center space-x-2\">\n      <span className=\"text-sm font-medium\">Mode:</span>\n      <button\n        onClick={onToggle}\n        className=\"flex items-center px-3 py-1 rounded-full bg-gray-200 focus:outline-none\"\n      >\n        <span\n          className={`w-6 h-6 rounded-full transform transition-transform ${mode === 'image' ? 'translate-x-4 bg-purple-500' : 'bg-blue-500'}`}\n        />\n        <span className=\"ml-2\">{mode === 'text' ? 'Text' : 'Image'}</span>\n      </button>\n    </div>\n  );\n}\n```",
        "testStrategy": "Test image generation by sending various prompts and verifying that images are generated correctly. Test the mode toggle to ensure it switches between text and image modes properly. Verify that generated images are displayed correctly in the UI and stored properly in the database. Test error handling for cases where image generation fails.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement New Chat Functionality",
        "description": "Add the ability to start a new chat session while preserving the previous conversation in the database.",
        "details": "1. Update the chat hook to support creating new chats:\n```typescript\n// hooks/useChat.ts (extended)\nexport function useChat() {\n  // ... existing state\n  \n  const startNewChat = useCallback(() => {\n    // Clear current messages\n    setMessages([]);\n    // Reset chat ID to trigger creation of a new session\n    setChatId(null);\n  }, []);\n  \n  // ... existing functions\n  \n  return { messages, sendMessage, isLoading, mode, toggleMode, startNewChat };\n}\n```\n\n2. Create a NewChatButton component:\n```tsx\n// components/NewChatButton.tsx\nexport function NewChatButton({ onClick }: { onClick: () => void }) {\n  return (\n    <button\n      onClick={onClick}\n      className=\"flex items-center px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors\"\n    >\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        className=\"h-5 w-5 mr-2\"\n        viewBox=\"0 0 20 20\"\n        fill=\"currentColor\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\"\n          clipRule=\"evenodd\"\n        />\n      </svg>\n      New Chat\n    </button>\n  );\n}\n```\n\n3. Update the main chat page to include the new chat button:\n```tsx\n// app/page.tsx\n'use client';\n\nimport { ChatContainer } from '@/components/ChatContainer';\nimport { MessageList } from '@/components/MessageList';\nimport { ChatInput } from '@/components/ChatInput';\nimport { NewChatButton } from '@/components/NewChatButton';\nimport { ModeToggle } from '@/components/ModeToggle';\nimport { useChat } from '@/hooks/useChat';\n\nexport default function ChatPage() {\n  const { messages, sendMessage, isLoading, mode, toggleMode, startNewChat } = useChat();\n  \n  return (\n    <ChatContainer>\n      <div className=\"flex justify-between items-center py-2 border-b\">\n        <ModeToggle mode={mode} onToggle={toggleMode} />\n        <NewChatButton onClick={startNewChat} />\n      </div>\n      \n      <MessageList messages={messages} isStreaming={isLoading && mode === 'text'} />\n      \n      <ChatInput\n        onSend={sendMessage}\n        mode={mode}\n        onToggleMode={toggleMode}\n        isLoading={isLoading}\n      />\n    </ChatContainer>\n  );\n}\n```\n\n4. Create a function to retrieve chat history from Supabase:\n```typescript\n// lib/supabase.ts\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n\nexport async function getChatSessions() {\n  const { data, error } = await supabase\n    .from('chat_sessions')\n    .select('*')\n    .order('updated_at', { ascending: false });\n  \n  if (error) throw error;\n  return data;\n}\n\nexport async function getChatMessages(chatId: string) {\n  const { data, error } = await supabase\n    .from('chat_messages')\n    .select('*')\n    .eq('chat_id', chatId)\n    .order('created_at', { ascending: true });\n  \n  if (error) throw error;\n  return data;\n}\n```\n<info added on 2025-10-01T11:47:10.420Z>\n5. Implementation Complete:\n\nSuccessfully implemented the complete new chat functionality with full database persistence:\n\n### Database Integration Layer\n- Created shared Supabase client in `_shared/supabase-client.ts`\n- TypeScript interfaces for ChatSession and Message types\n\n### Enhanced Edge Functions\n**chat-text & chat-image:**\n- Auto-create/update chat sessions\n- Save user messages before processing\n- Save AI responses to database\n- Link all messages via chat_id\n\n### New API Endpoint\n- `get-chat-history` function to retrieve sessions and messages\n- Supports getting all sessions or specific chat by ID\n\n### Frontend Integration\n- Fixed chatId generation and usage\n- New Chat button clears and resets for new session\n- All messages properly saved to database\n\n### Files Created/Modified:\n- NEW: `supabase/functions/_shared/supabase-client.ts`\n- NEW: `supabase/functions/get-chat-history/index.ts`\n- UPDATED: `supabase/functions/chat-text/index.ts`\n- UPDATED: `supabase/functions/chat-image/index.ts`\n- UPDATED: `app/src/app/page.tsx`\n- UPDATED: All deno.json files\n</info added on 2025-10-01T11:47:10.420Z>",
        "testStrategy": "Test the new chat functionality by creating multiple chat sessions and verifying that each session is stored separately in the database. Verify that starting a new chat clears the current messages and creates a new chat session. Test that previous chats can be retrieved from the database correctly.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Error Handling and Loading States",
        "description": "Add comprehensive error handling and loading state indicators to improve user experience during API calls and data processing.",
        "details": "1. Create reusable error handling utilities:\n```typescript\n// lib/errorHandling.ts\nexport class ApiError extends Error {\n  constructor(message: string, public status: number) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nexport function handleApiError(error: unknown): { message: string, status: number } {\n  if (error instanceof ApiError) {\n    return { message: error.message, status: error.status };\n  }\n  \n  if (error instanceof Error) {\n    return { message: error.message, status: 500 };\n  }\n  \n  return { message: 'An unknown error occurred', status: 500 };\n}\n```\n\n2. Create loading state components:\n```tsx\n// components/LoadingSpinner.tsx\nexport function LoadingSpinner({ size = 'medium' }: { size?: 'small' | 'medium' | 'large' }) {\n  const sizeClasses = {\n    small: 'w-4 h-4',\n    medium: 'w-8 h-8',\n    large: 'w-12 h-12',\n  };\n  \n  return (\n    <div className=\"flex justify-center items-center\">\n      <div className={`${sizeClasses[size]} border-4 border-gray-200 border-t-blue-500 rounded-full animate-spin`} />\n    </div>\n  );\n}\n\n// components/LoadingMessage.tsx\nexport function LoadingMessage({ mode }: { mode: 'text' | 'image' }) {\n  return (\n    <div className=\"flex items-center space-x-2 p-3 bg-gray-100 rounded-lg max-w-[80%]\">\n      <LoadingSpinner size=\"small\" />\n      <p>{mode === 'text' ? 'Thinking...' : 'Generating image...'}</p>\n    </div>\n  );\n}\n```\n\n3. Update the MessageList component to show loading states:\n```tsx\n// components/MessageList.tsx\nexport function MessageList({ messages, isLoading, mode }: MessageListProps) {\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n  \n  return (\n    <div className=\"flex-1 overflow-y-auto p-4\">\n      {messages.map((message, index) => (\n        <MessageItem\n          key={index}\n          message={message}\n          isStreaming={index === messages.length - 1 && message.role === 'assistant' && isLoading && mode === 'text'}\n        />\n      ))}\n      \n      {isLoading && messages.length > 0 && messages[messages.length - 1].role === 'user' && (\n        <div className=\"flex justify-start mb-4\">\n          <LoadingMessage mode={mode} />\n        </div>\n      )}\n      \n      <div ref={messagesEndRef} />\n    </div>\n  );\n}\n```\n\n4. Implement error toast notifications:\n```tsx\n// components/ErrorToast.tsx\nimport { useEffect, useState } from 'react';\n\nexport function ErrorToast({ message, onClose }: { message: string, onClose: () => void }) {\n  const [isVisible, setIsVisible] = useState(true);\n  \n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setIsVisible(false);\n      setTimeout(onClose, 300); // Allow time for exit animation\n    }, 5000);\n    \n    return () => clearTimeout(timer);\n  }, [onClose]);\n  \n  return (\n    <div\n      className={`fixed bottom-4 right-4 bg-red-500 text-white p-4 rounded-md shadow-lg transition-opacity duration-300 ${isVisible ? 'opacity-100' : 'opacity-0'}`}\n    >\n      <div className=\"flex items-center\">\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-6 w-6 mr-2\"\n          fill=\"none\"\n          viewBox=\"0 0 24 24\"\n          stroke=\"currentColor\"\n        >\n          <path\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth={2}\n            d=\"M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n          />\n        </svg>\n        <p>{message}</p>\n        <button\n          onClick={() => {\n            setIsVisible(false);\n            setTimeout(onClose, 300);\n          }}\n          className=\"ml-4 text-white\"\n        >\n          ×\n        </button>\n      </div>\n    </div>\n  );\n}\n\n// hooks/useErrorToast.ts\nexport function useErrorToast() {\n  const [errors, setErrors] = useState<string[]>([]);\n  \n  const showError = useCallback((message: string) => {\n    setErrors(prev => [...prev, message]);\n  }, []);\n  \n  const dismissError = useCallback((index: number) => {\n    setErrors(prev => prev.filter((_, i) => i !== index));\n  }, []);\n  \n  const ErrorToasts = useCallback(() => (\n    <>\n      {errors.map((error, index) => (\n        <ErrorToast\n          key={index}\n          message={error}\n          onClose={() => dismissError(index)}\n        />\n      ))}\n    </>\n  ), [errors, dismissError]);\n  \n  return { showError, ErrorToasts };\n}\n```\n\n5. Update the main chat page to include error handling:\n```tsx\n// app/page.tsx (updated)\nexport default function ChatPage() {\n  const { messages, sendMessage, isLoading, mode, toggleMode, startNewChat } = useChat();\n  const { showError, ErrorToasts } = useErrorToast();\n  \n  const handleSendMessage = useCallback(async (content: string) => {\n    try {\n      await sendMessage(content);\n    } catch (error) {\n      showError(error instanceof Error ? error.message : 'An error occurred');\n    }\n  }, [sendMessage, showError]);\n  \n  return (\n    <ChatContainer>\n      {/* ... existing components */}\n      \n      <ChatInput\n        onSend={handleSendMessage}\n        mode={mode}\n        onToggleMode={toggleMode}\n        isLoading={isLoading}\n      />\n      \n      <ErrorToasts />\n    </ChatContainer>\n  );\n}\n```",
        "testStrategy": "Test error handling by simulating various error conditions (API failures, network issues, etc.) and verifying that appropriate error messages are displayed. Test loading states by simulating slow responses and verifying that loading indicators are displayed correctly. Verify that error messages are dismissed after the specified timeout and that loading indicators are removed when operations complete.",
        "priority": "medium",
        "dependencies": [
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Optimize API Usage and Response Formatting",
        "description": "Optimize API calls to reduce costs and improve performance, and enhance the formatting of AI responses for better readability.",
        "details": "1. Implement API request throttling and caching:\n```typescript\n// lib/apiThrottling.ts\ninterface CacheEntry {\n  data: any;\n  timestamp: number;\n}\n\nconst cache = new Map<string, CacheEntry>();\nconst CACHE_TTL = 1000 * 60 * 5; // 5 minutes\n\nexport async function throttledRequest<T>(\n  key: string,\n  requestFn: () => Promise<T>,\n  options: { cacheTTL?: number; forceRefresh?: boolean } = {}\n): Promise<T> {\n  const { cacheTTL = CACHE_TTL, forceRefresh = false } = options;\n  \n  // Check cache if not forcing refresh\n  if (!forceRefresh) {\n    const cached = cache.get(key);\n    if (cached && Date.now() - cached.timestamp < cacheTTL) {\n      return cached.data;\n    }\n  }\n  \n  // Make the actual request\n  const data = await requestFn();\n  \n  // Update cache\n  cache.set(key, {\n    data,\n    timestamp: Date.now(),\n  });\n  \n  return data;\n}\n```\n\n2. Implement markdown formatting for text responses:\n```typescript\n// lib/markdownFormatting.ts\nimport { marked } from 'marked';\nimport DOMPurify from 'dompurify';\n\nexport function formatMarkdown(text: string): string {\n  // Convert markdown to HTML\n  const rawHtml = marked(text);\n  \n  // Sanitize HTML to prevent XSS\n  const sanitizedHtml = DOMPurify.sanitize(rawHtml);\n  \n  return sanitizedHtml;\n}\n```\n\n3. Create a component to render formatted text:\n```tsx\n// components/FormattedText.tsx\nimport { formatMarkdown } from '@/lib/markdownFormatting';\n\nexport function FormattedText({ text }: { text: string }) {\n  return (\n    <div\n      className=\"prose prose-sm max-w-none\"\n      dangerouslySetInnerHTML={{ __html: formatMarkdown(text) }}\n    />\n  );\n}\n```\n\n4. Update the MessageItem component to use formatted text:\n```tsx\n// components/MessageItem.tsx (updated)\nexport function MessageItem({ message, isStreaming }: { message: ChatMessage, isStreaming?: boolean }) {\n  const isUser = message.role === 'user';\n  return (\n    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>\n      <div className={`max-w-[80%] p-3 rounded-lg ${isUser ? 'bg-blue-500 text-white' : 'bg-gray-100'}`}>\n        {message.type === 'text' ? (\n          isStreaming ? (\n            <StreamingText text={message.content} />\n          ) : (\n            <FormattedText text={message.content} />\n          )\n        ) : (\n          <img src={message.image_url} alt=\"Generated image\" className=\"rounded\" />\n        )}\n      </div>\n    </div>\n  );\n}\n```\n\n5. Optimize OpenAI API calls with proper parameters:\n```typescript\n// lib/openai.ts (optimized)\nexport async function generateChatCompletion(messages: any[]) {\n  return openai.chat.completions.create({\n    model: 'gpt-4.1-nano-2025-04-14',\n    messages,\n    stream: true,\n    temperature: 0.7, // Add temperature for more controlled responses\n    max_tokens: 1000, // Limit token usage\n    presence_penalty: 0.1, // Slight penalty for repetition\n    frequency_penalty: 0.1, // Slight penalty for frequent tokens\n  });\n}\n\nexport async function generateImage(prompt: string) {\n  // Optimize prompt for better image generation\n  const enhancedPrompt = `High quality, detailed image of: ${prompt}`;\n  \n  return openai.images.generate({\n    model: 'gpt-image-1',\n    prompt: enhancedPrompt,\n    n: 1,\n    size: '1024x1024',\n    quality: 'standard', // Use standard quality to balance cost and quality\n  });\n}\n```",
        "testStrategy": "Test API optimization by measuring response times and API usage before and after implementation. Verify that caching works correctly by making identical requests and confirming that cached responses are used. Test markdown formatting with various types of content (code blocks, lists, tables, etc.) to ensure proper rendering. Verify that the optimized API parameters produce appropriate results without unnecessary token usage.",
        "priority": "low",
        "dependencies": [
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Cross-Browser Compatibility and Responsive Design",
        "description": "Ensure the application works consistently across different browsers and device sizes with responsive design principles.",
        "details": "1. Create responsive layout utilities:\n```typescript\n// hooks/useMediaQuery.ts\nimport { useState, useEffect } from 'react';\n\nexport function useMediaQuery(query: string): boolean {\n  const [matches, setMatches] = useState(false);\n  \n  useEffect(() => {\n    const media = window.matchMedia(query);\n    if (media.matches !== matches) {\n      setMatches(media.matches);\n    }\n    \n    const listener = () => setMatches(media.matches);\n    media.addEventListener('change', listener);\n    \n    return () => media.removeEventListener('change', listener);\n  }, [matches, query]);\n  \n  return matches;\n}\n```\n\n2. Update the ChatContainer component to be responsive:\n```tsx\n// components/ChatContainer.tsx (responsive)\nexport function ChatContainer({ children }: { children: React.ReactNode }) {\n  return (\n    <div className=\"flex flex-col h-screen w-full max-w-3xl mx-auto p-2 sm:p-4\">\n      <header className=\"py-2 sm:py-4 border-b\">\n        <h1 className=\"text-xl sm:text-2xl font-bold\">AI Chat Assistant</h1>\n      </header>\n      <main className=\"flex-1 overflow-hidden flex flex-col\">\n        {children}\n      </main>\n    </div>\n  );\n}\n```\n\n3. Make the ChatInput component responsive:\n```tsx\n// components/ChatInput.tsx (responsive)\nexport function ChatInput({ onSend, mode, onToggleMode, isLoading }: ChatInputProps) {\n  const [input, setInput] = useState('');\n  const isMobile = useMediaQuery('(max-width: 640px)');\n  \n  return (\n    <div className=\"border-t p-2 sm:p-4\">\n      <div className=\"flex items-center mb-2 justify-between\">\n        <ModeToggle mode={mode} onToggle={onToggleMode} />\n        {!isMobile && (\n          <div className=\"text-xs text-gray-500\">\n            {mode === 'text' ? 'Chat with AI' : 'Generate images with AI'}\n          </div>\n        )}\n      </div>\n      <div className=\"flex\">\n        <textarea\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          placeholder={mode === 'text' ? 'Type a message...' : 'Describe the image you want...'}\n          className=\"flex-1 p-2 border rounded-l-md resize-none h-10 sm:h-12 max-h-32\"\n          rows={1}\n          onKeyDown={(e) => {\n            if (e.key === 'Enter' && !e.shiftKey) {\n              e.preventDefault();\n              if (input.trim() && !isLoading) {\n                onSend(input);\n                setInput('');\n              }\n            }\n          }}\n        />\n        <button\n          onClick={() => {\n            if (input.trim() && !isLoading) {\n              onSend(input);\n              setInput('');\n            }\n          }}\n          disabled={isLoading || !input.trim()}\n          className=\"bg-blue-500 text-white p-2 rounded-r-md disabled:bg-blue-300\"\n        >\n          {isLoading ? (\n            <LoadingSpinner size=\"small\" />\n          ) : (\n            <svg\n              xmlns=\"http://www.w3.org/2000/svg\"\n              className=\"h-5 w-5\"\n              viewBox=\"0 0 20 20\"\n              fill=\"currentColor\"\n            >\n              <path\n                fillRule=\"evenodd\"\n                d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z\"\n                clipRule=\"evenodd\"\n              />\n            </svg>\n          )}\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n4. Add cross-browser compatibility fixes:\n```css\n/* globals.css */\n/* Fix for iOS input zoom */\n@media screen and (max-width: 768px) {\n  input, select, textarea {\n    font-size: 16px;\n  }\n}\n\n/* Fix for Firefox textarea height */\ntextarea {\n  min-height: 2.5rem;\n}\n\n/* Fix for Safari border radius */\n@supports (-webkit-touch-callout: none) {\n  .rounded-md {\n    -webkit-mask-image: -webkit-radial-gradient(white, black);\n  }\n}\n```\n\n5. Add browser detection for specific fixes:\n```typescript\n// lib/browserDetection.ts\nexport function detectBrowser(): string {\n  if (typeof window === 'undefined') return 'server';\n  \n  const userAgent = window.navigator.userAgent;\n  \n  if (userAgent.indexOf('Chrome') > -1) return 'chrome';\n  if (userAgent.indexOf('Safari') > -1) return 'safari';\n  if (userAgent.indexOf('Firefox') > -1) return 'firefox';\n  if (userAgent.indexOf('MSIE') > -1 || userAgent.indexOf('Trident') > -1) return 'ie';\n  if (userAgent.indexOf('Edge') > -1) return 'edge';\n  \n  return 'unknown';\n}\n\nexport function applyBrowserFixes(): void {\n  const browser = detectBrowser();\n  \n  if (browser === 'safari') {\n    // Apply Safari-specific fixes\n    document.documentElement.classList.add('safari');\n  }\n  \n  if (browser === 'firefox') {\n    // Apply Firefox-specific fixes\n    document.documentElement.classList.add('firefox');\n  }\n}\n```\n\n6. Create a component to handle viewport height issues on mobile:\n```tsx\n// components/ViewportHandler.tsx\nimport { useEffect } from 'react';\n\nexport function ViewportHandler() {\n  useEffect(() => {\n    // Fix for mobile viewport height issues\n    const setVh = () => {\n      const vh = window.innerHeight * 0.01;\n      document.documentElement.style.setProperty('--vh', `${vh}px`);\n    };\n    \n    setVh();\n    window.addEventListener('resize', setVh);\n    \n    return () => window.removeEventListener('resize', setVh);\n  }, []);\n  \n  return null;\n}\n```",
        "testStrategy": "Test the application on multiple browsers (Chrome, Firefox, Safari, Edge) and devices (desktop, tablet, mobile) to verify consistent appearance and functionality. Use browser developer tools to simulate different screen sizes and verify responsive behavior. Test touch interactions on mobile devices to ensure they work as expected. Verify that the application handles orientation changes properly on mobile devices.",
        "priority": "low",
        "dependencies": [
          3,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-26T13:45:36.871Z",
      "updated": "2025-10-01T11:48:19.850Z",
      "description": "Tasks for master context"
    }
  }
}